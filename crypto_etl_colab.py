# -*- coding: utf-8 -*-
"""Proyecto_Cryptos_ModVII.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UuDyW5ajc1MSZQN309_2GzVhfwvcnMuV

# **ðŸ’»INGESTA DE DATOS DESDE UNA APIðŸ’°**
**COINGECKOðŸ’±**

**Diccionario de datos**
* **ðŸ”‘symbol:** Identificador Ãºnico en minÃºsculas segÃºn estÃ¡ndar CoinGecko.
* **ðŸ“Šcurrent_price:** Precio actual en USD con precisiÃ³n decimal, actualizado en tiempo real.
* **ðŸŽ¯price_change_percentage_24h:** VariaciÃ³n porcentual del precio en las Ãºltimas 24 horas exactas.
* **ðŸ’°market_cap:** CapitalizaciÃ³n de mercado en USD, calculada en tiempo real.
* **ðŸ“ˆtotal_volume:** Volumen total de trading en USD durante Ãºltimas 24 horas.
* **ðŸ“Šhigh_24h:** Precio mÃ¡ximo alcanzado durante las Ãºltimas 24 horas de trading.
* **ðŸ“Šlow_24h:** Precio mÃ­nimo alcanzado durante las Ãºltimas 24 horas de trading.
* **ðŸŽ¯trend_classification:** CategorizaciÃ³n de tendencia segÃºn algoritmo personalizado agregado una ves realizado la limpieza.
"""

import requests
import pandas as pd

def coingecko_api():
    """
    API de CoinGecko - alternativa confiable
    """
    url = "https://api.coingecko.com/api/v3/coins/markets"

    params = {
        'vs_currency': 'usd',
        'order': 'market_cap_desc',
        'per_page': 100,  # NÃºmero de resultados
        'page': 1,
        'sparkline': False
    }

    try:
        r = requests.get(url, params=params, timeout=30)
        print(f"Status Code: {r.status_code}")

        if r.status_code == 200:
            js = r.json()
            df = pd.DataFrame(js)

            # Seleccionar columnas relevantes
            columnas = ['symbol', 'current_price', 'price_change_percentage_24h',
                       'market_cap', 'total_volume', 'high_24h', 'low_24h']

            df = df[columnas]
            print(f"Datos obtenidos: {len(df)} criptomonedas")

            print("\nTop 10 por capitalizaciÃ³n de mercado:")
            print(df.head(10))

            return df
        else:
            print(f"Error: {r.status_code}")
            return None

    except Exception as e:
        print(f"Error: {e}")
        return None

df = coingecko_api()

df.info()

# Compruebe si faltan valores en cada columna
missing_values = df.isnull().sum()

# Mostrar el recuento de valores faltantes
print("Valores faltantes por columna")
print(missing_values)

# Completar los valores numÃ©ricos faltantes con la mediana de cada columna
for col in df.select_dtypes(include=['float64', 'Int64']).columns:
    if df[col].isnull().any():
        median_value = df[col].median()
        df[col] = df[col].fillna(median_value)

# Comprobar si faltan valores restantes
print("Missing values after filling:")
print(df.isnull().sum())

display(df.head())

df.describe()

# Primero definir la funciÃ³n
def classify_trend(row):
    """
    FunciÃ³n para clasificar la tendencia.
    """
    price_change_api = row["price_change_percentage_24h"] / 100

    if price_change_api >= 0.05:
        return "Tendencia fuerte alcista"
    elif price_change_api > 0.01:
        return "Tendencia moderada alcista"
    elif price_change_api <= -0.05:
        return "Tendencia fuerte bajista"
    elif price_change_api < -0.01:
        return "Tendencia moderada bajista"
    else:
        return "Tendencia estable"

# Ahora aplicar la funciÃ³n para crear la columna de tendencia
df['tendencia'] = df.apply(classify_trend, axis=1)

# Mostrar los resultados
print("DistribuciÃ³n de tendencias:")
print(df['tendencia'].value_counts())
print("\n" + "="*50 + "\n")

# Mostrar algunas filas con los resultados
print("Primeras 10 filas con la clasificaciÃ³n de tendencia:")
print(df[['current_price', 'price_change_percentage_24h', 'tendencia']].head(10))
print("\n" + "="*50 + "\n")

# Mostrar conteo por categorÃ­a de tendencia
print("Resumen de clasificaciÃ³n:")
tendencia_counts = df['tendencia'].value_counts()
for tendencia, count in tendencia_counts.items():
    print(f"{tendencia}: {count} criptomonedas")

# Opcional: Ver estadÃ­sticas de price_change_percentage_24h por tendencia
print("\n" + "="*50 + "\n")
print("EstadÃ­sticas de cambio porcentual por tendencia:")
print(df.groupby('tendencia')['price_change_percentage_24h'].describe())

"""# **ðŸ’»INGESTA DE DATOS DESDE UN ARCHIVO CSV DE KAGGLEðŸ’°**
**CRYPTO CURRENCYðŸ’±**

Diccionario de datos
* **1ï¸âƒ£rank:** PosiciÃ³n ranking por capitalizaciÃ³n de mercado, donde 1 representa la criptomoneda con mayor market cap
* **ðŸ’²coin_name:** Nombre comercial completo de la criptomoneda segÃºn su proyecto oficial
* **ðŸ”‘symbol:** TSÃ­mbolo ticker utilizado en exchanges para identificar la criptomoneda
* **ðŸ’µcurrent_price:** Precio de mercado actual expresado en dÃ³lares americanos (USD) con formato monetario
* **ðŸ“Š1h:** Cambio porcentual del precio en las Ãºltimas 1 hora, indicador de volatilidad a corto plazo
* **ðŸ“Š24h:** Cambio porcentual del precio en las Ãºltimas 24 horas, mÃ©trica clave para tendencias diarias
* **ðŸ“Š7d:** Cambio porcentual del precio en los Ãºltimos 7 dÃ­as, indicador de tendencia semanal
* **ðŸ“Š30d:** Cambio porcentual del precio en los Ãºltimos 30 dÃ­as, perspectiva de tendencia mensual
* **ðŸ“Š24h_volume:** Volumen total de trading en dÃ³lares durante las Ãºltimas 24 horas, indicador de liquidez
* **ðŸ“ˆcirculating_supply:** Cantidad de monedas actualmente en circulaciÃ³n y disponibles en el mercado
* **ðŸ’±total_supply:** Suministro mÃ¡ximo total que existirÃ¡ para la criptomoneda, incluye no circulante
* **ðŸ’°market_cap:** CapitalizaciÃ³n de mercado calculada como Precio Ã— Circulating Supply
* **ðŸŽ¯is_outlier:** Para clasificar a los datos que tienen un precio atipico, con el fin de no eliminarlo, dado el entorno de volatilidad que tiene este sector
"""

# Carga el archivo CSV
btcusd_df = pd.read_csv("/content/CryptocurrencyData.csv")

# Muestra las primeras filas del DataFrame para verificar que se cargÃ³ correctamente
display(btcusd_df.head())

btcusd_df.info()

"""Limpieza de los datos"""

# Quitar espacios al inicio y final de los nombres de columnas
btcusd_df.columns = btcusd_df.columns.str.strip()

# Renombrar columnas del DataFrame btcusd_df
btcusd_df = btcusd_df.rename(columns={
    'Coin Name': 'coin',
    'Symbol': 'symbol',
    'Price': 'current_price',
    '24h Volume': '24h_volume',
    'Circulating Supply': 'circulating_supply',
    'Total Supply': 'total_supply',
    'Market Cap': 'market_cap'
})
#Eliminando la columna Rank
btcusd_df = btcusd_df.drop(columns=['Rank'])

#Elimina todas las comas (,) de los valores de la variable de "current_price" y los convierte a numero
btcusd_df['current_price'] = btcusd_df['current_price'].astype(str).str.replace(',', '', regex=False)
btcusd_df['current_price'] = pd.to_numeric(btcusd_df['current_price'], errors='coerce')

#Elimina todas las comas (,) de los valores de la variable de "circulating_supply" y los convierte a numero
btcusd_df['circulating_supply'] = btcusd_df['circulating_supply'].astype(str).str.replace(',', '', regex=False)
btcusd_df['circulating_supply'] = pd.to_numeric(btcusd_df['circulating_supply'], errors='coerce')

#Convierte las columnas '1h', '24h', '7d', '30d' en porcentaje, sacando el simbolo de porcentaje de la misma (%)
percentage_cols = ['1h', '24h', '7d', '30d']
for col in percentage_cols:
    btcusd_df[col] = btcusd_df[col].astype(str).str.replace('%', '', regex=False)
    btcusd_df[col] = pd.to_numeric(btcusd_df[col], errors='coerce')
    btcusd_df[col] = btcusd_df[col] / 100

# Crea una variable llamada volume_market_cols
volume_market_cols = ['24h_volume', 'market_cap']
for col in volume_market_cols:
    # Eliminar '$' y "," manejando los espacios potenciales
    btcusd_df[col] = btcusd_df[col].astype(str).str.replace(r'[$, ]', '', regex=True)
    # Convierte a numeros flotante, forzando errores
    btcusd_df[col] = pd.to_numeric(btcusd_df[col], errors='coerce')

# Se crea un funcion para poder convertir los valores en numeros, considerando que estos datos tienen texto de "millones" y "billones", para ello se debe eliminar este texto
def clean_total_supply(supply_str):
    if pd.isna(supply_str) or supply_str == '-' or supply_str == '':
        return pd.NA

    supply_str = str(supply_str).replace(',', '').replace('$', '').strip()
    supply_str = supply_str.replace(' ', '') # Elimina los espacios restantes

    if 'Billion' in supply_str:
        supply_str = supply_str.replace('Billion', '')
        try:
            return int(float(supply_str) * 1_000_000_000)
        except ValueError:
            return pd.NA
    elif 'Million' in supply_str:
        supply_str = supply_str.replace('Million', '')
        try:
            return int(float(supply_str) * 1_000_000)
        except ValueError:
            return pd.NA
    else:
        try:
            # Maneja casos que son solo nÃºmeros o tienen puntos decimales
            return int(float(supply_str))
        except ValueError:
            return pd.NA

btcusd_df['total_supply'] = btcusd_df['total_supply'].apply(clean_total_supply)
btcusd_df['total_supply'] = btcusd_df['total_supply'].astype('Int64')

display(btcusd_df.head())
display(btcusd_df.info())

# Compruebe si faltan valores en cada columna
missing_values = btcusd_df.isnull().sum()

# Mostrar el recuento de valores faltantes
print("Missing values per column:")
print(missing_values)

"""Validacion de los datos"""

# Completar los valores numÃ©ricos faltantes con la mediana de cada columna
for col in btcusd_df.select_dtypes(include=['float64', 'Int64']).columns:
    if btcusd_df[col].isnull().any():
        median_value = btcusd_df[col].median()
        btcusd_df[col] = btcusd_df[col].fillna(median_value)

# Comprobar si faltan valores restantes
print("Missing values after filling:")
print(btcusd_df.isnull().sum())

display(btcusd_df.head())

btcusd_df.describe()

#Observar los datos duplicados
print(btcusd_df.duplicated().sum())

"""Clasificacion y procesamiento de los datos"""

import matplotlib.pyplot as plt
btcusd_df['current_price'].plot(kind='box')
plt.show()

#Observacion de los outliers
q1 = btcusd_df['current_price'].quantile(0.25)
q3 = btcusd_df['current_price'].quantile(0.75)
iqr = q3 - q1

# Definir umbrales
lower = q1 - 1.5 * iqr
upper = q3 + 1.5 * iqr

# Marcar outliers sin eliminarlos
btcusd_df['is_outlier'] = ~btcusd_df['current_price'].between(lower, upper)
btcusd_df.head()

"""Almacenamiento de datos"""

# Guardado del DataFrame de la API en un archivo CSV
df.to_csv('/content/api_cryptocurrency_data_final.csv', index=False)
print("Datos de la API guardados como: 'api_cryptocurrency_data_final.csv'")

# Guardado del DataFrame de Kaggle en un archivo CSV (historico)
btcusd_df.to_csv('/content/cleaned_cryptocurrency_data_final.csv', index=False)
print("Datos historicos posterior a la limpieza guardados como: 'cleaned_cryptocurrency_data_final.csv'")

"""Reporte de calidad con ProfileReport"""

!pip install ydata_profiling pandas

from ydata_profiling import ProfileReport
import pandas as pd

#Reporte para los datos extraido de la API de CoinGecko
df = pd.read_csv("/content/api_cryptocurrency_data.csv")
profile = ProfileReport(df, title="Reporte de Calidad - Criptomonedas API")
profile.to_file("cryptos_api_report.html")

import pandas as pd
from ydata_profiling import ProfileReport

#Reporte para los datos extraido de la API de CoinGecko
df = pd.read_csv("/content/cleaned_cryptocurrency_data.csv")
# Generar el reporte con el modo mÃ­nimo (minimiza la memoria usada)
profile = ProfileReport(df, title="Reporte de Calidad - Criptomonedas", minimal=True)
# Guardar el archivo
profile.to_file("cryptos_kaggle_report.html")
